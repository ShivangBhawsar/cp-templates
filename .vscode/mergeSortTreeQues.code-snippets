{
	"": {
		"prefix": "mergeSortTreeQues",
		"body": [
		  "// https://www.interviewbit.com/test/780ba56187/?signature=BAhpA6D3Bw%3D%3D--39a5611d14d2fb712f0c139659d8186fc0cd77ea#/problem_4",
		  "#include <bits/stdc++.h>",
		  "using namespace std;",
		  "typedef long long int ll;",
		  "#define rep(g, i, n) for (int g = i; g < n; g++)",
		  "#define rev(g, n, i) for (int g = n - 1; g >= i; g--)",
		  "#define all(v) v.begin(), v.end()",
		  "#define pb push_back",
		  "#define ve vector",
		  "#define rem 1000000007",
		  "",
		  "struct merge_sort_tree",
		  "{",
		  "    //initialise the tree",
		  "    //do updates for each array element",
		  "    //get your queries",
		  "    //have a look at what you assign in init,ex: 0 for sums and 1e9 for min",
		  "    int size;",
		  "    vector<ve<int>> tree, pre;",
		  "    void init(int &n)",
		  "    {",
		  "        size = 1;",
		  "        while (size < n)",
		  "            size *= 2;",
		  "        tree.assign(2 * size, {});",
		  "        pre.assign(2 * size, {});",
		  "    }",
		  "    ve<int> merge(ve<int> &a, ve<int> &b)",
		  "    {",
		  "        ll n = a.size(), m = b.size();",
		  "        ve<int> ans;",
		  "        ll p1 = 0, p2 = 0;",
		  "        while (p1 < n && p2 < m)",
		  "        {",
		  "            if (a[p1] < b[p2])",
		  "            {",
		  "                ans.pb(a[p1]);",
		  "                p1++;",
		  "            }",
		  "            else",
		  "            {",
		  "                ans.pb(b[p2]);",
		  "                p2++;",
		  "            }",
		  "        }",
		  "        rep(i, p1, n)",
		  "        {",
		  "            ans.pb(a[i]);",
		  "        }",
		  "        rep(i, p2, m)",
		  "        {",
		  "            ans.pb(b[i]);",
		  "        }",
		  "        return ans;",
		  "    }",
		  "    ve<int> prefix(ve<int> &tr)",
		  "    {",
		  "        int n = tr.size();",
		  "        ve<int> ans(n);",
		  "        rep(i, 0, n)",
		  "        {",
		  "            if (i == 0)",
		  "            {",
		  "                ans[i] = tr[i];",
		  "            }",
		  "            else",
		  "            {",
		  "                ans[i] = ans[i - 1] + tr[i];",
		  "                ans[i] %= rem;",
		  "            }",
		  "        }",
		  "        return ans;",
		  "    }",
		  "    //we are going from lx to rx both included",
		  "    void build(int x, int lx, int rx, ve<int> &arr)",
		  "    {",
		  "        if (rx == lx)",
		  "        {",
		  "            tree[x] = {arr[lx]};",
		  "            pre[x] = {arr[lx]};",
		  "            return;",
		  "        }",
		  "        ll mid = (lx + rx) / 2;",
		  "        build(2*x+1,lx,mid,arr);",
		  "        build(2*x+2,mid+1,rx,arr);",
		  "",
		  "        tree[x] = merge(tree[2 * x + 1], tree[2 * x + 2]);",
		  "        pre[x] = prefix(tree[x]);",
		  "    }",
		  "    void build(ve<int> &arr)",
		  "    {",
		  "        build(0, 0, size - 1, arr);",
		  "    }",
		  "",
		  "    void query1(int &l, int &r, int x, int lx, int rx, ve <int> &v1) //find all segtree ranges of element from L to R",
		  "    {",
		  "        if (lx > r || l > rx)",
		  "            return; //**",
		  "        if (lx >= l && rx <= r)",
		  "        {",
		  "            v1.push_back(x);",
		  "            return;",
		  "        }",
		  "        int mid = (lx + rx) / 2;",
		  "        query1(l, r, 2 * x + 1, lx, mid, v1);",
		  "        query1(l, r, 2 * x + 2, mid + 1, rx, v1);",
		  "    }",
		  "    pair<int, int> query2(int &l, int &r, int x, int lx, int rx, int k) //find sum of elements <= K from L to R",
		  "    {",
		  "        if (lx > r || l > rx)",
		  "            return {0, 0}; //**",
		  "        if (lx >= l && rx <= r)",
		  "        {",
		  "            // cout<<\"lx... \"<<lx<<\" rx... \"<<rx<<\"\\n\";",
		  "            int b1 = upper_bound(all(tree[x]), k) - tree[x].begin();",
		  "            if (b1 > 0)",
		  "                return {pre[x][b1 - 1], b1};",
		  "            return {0, 0};",
		  "        }",
		  "        int mid = (lx + rx) / 2;",
		  "        pair<int, int> s1 = query2(l, r, 2 * x + 1, lx, mid, k);",
		  "        pair<int, int> s2 = query2(l, r, 2 * x + 2, mid + 1, rx, k);",
		  "        return {(s1.first + s2.first) % rem, s1.second + s2.second};",
		  "    }",
		  "    bool isposs(int &val,int &res, ve <int> &v1)",
		  "    {",
		  "        int n=v1.size(),cnt=0;//find cnt of all values less than or equal to val",
		  "        for (auto &x: v1)",
		  "        {",
		  "            cnt+=upper_bound(all(tree[x]),val)-tree[x].begin();",
		  "        }",
		  "        if (cnt>=res)",
		  "            return true;",
		  "        return false;",
		  "    }",
		  "    int query(int &l, int &r, int &res)",
		  "    {",
		  "        ve <int> v1;",
		  "        query1(l, r, 0, 0, size - 1, v1);",
		  "        int K;",
		  "        int low=1,high=1e9;",
		  "        while (low<=high)",
		  "        {",
		  "            if (high-low<=3)",
		  "            {",
		  "                rep (i,low,high+1)",
		  "                {",
		  "                    if (isposs(i,res,v1))",
		  "                    {",
		  "                        K=i;",
		  "                        break;",
		  "                    }",
		  "                }",
		  "                break;",
		  "            }",
		  "            int mid=(low+high)/2;",
		  "            if (isposs(mid,res,v1))",
		  "            {",
		  "                high=mid;",
		  "            }",
		  "            else",
		  "            {",
		  "                low=mid;",
		  "            }",
		  "        }",
		  "        pair<int, int> p = query2(l, r, 0, 0, size - 1, K);",
		  "        long long ans = (ll)p.first - ((ll)(p.second - res) * (ll)K) % rem;",
		  "        ans += rem;",
		  "        ans %= rem;",
		  "        return ans;",
		  "    }",
		  "};",
		  "int main()",
		  "{",
		  "    // freopen(\"input1.txt\", \"r\", stdin);",
		  "    // freopen(\"output.txt\", \"w\", stdout);",
		  "    /*ll tests;",
		  "    cin>>tests;",
		  "    rep (gg,0,tests)",
		  "    {}*/",
		  "    // ve<ve<ll>> A = {{1, 2}, {4, 2}, {3, 2}, {4, 3}}, B = {{2, 3, 1, 1},{1,4,2,1}}; //input",
		  "    // ve<ve<ll>> A = {{2, 3}, {4, 5}, {2, 1}}, B = {{2, 3, 0, 1}}; //input",
		  "    ve<ve<ll>> A = {{7, 8}, {10, 10}, {4, 1},{8,5},{4,2},{1,2},{5,6},{6,7}}, B = {{5,8,2,0},{2,5,2,0}}; //input",
		  "    int n = A.size(), q = B.size();",
		  "    merge_sort_tree S; //use only one tree",
		  "    S.init(n);",
		  "    ve<int> preminsum(n), prex(n), arr(n);",
		  "    rep(i, 0, n)",
		  "    {",
		  "        if (i == 0)",
		  "        {",
		  "            preminsum[0] = min(A[i][0], A[i][1]);",
		  "        }",
		  "        else",
		  "        {",
		  "            preminsum[i] = preminsum[i - 1] + min(A[i][0], A[i][1]);",
		  "            preminsum[i] %= rem;",
		  "        }",
		  "        if (A[i][0] < A[i][1])",
		  "        {",
		  "            arr[i] = (A[i][1] - A[i][0]);",
		  "            // Syarr.pb(1e10);",
		  "            if (i == 0)",
		  "            {",
		  "                prex[0] = 1;",
		  "            }",
		  "            else",
		  "            {",
		  "                prex[i] = prex[i - 1] + 1;",
		  "            }",
		  "        }",
		  "        else",
		  "        {",
		  "            arr[i] = 2e9;",
		  "            if (i == 0)",
		  "            {",
		  "                prex[0] = 0;",
		  "            }",
		  "            else",
		  "            {",
		  "                prex[i] = prex[i - 1];",
		  "            }   ",
		  "        }",
		  "    }",
		  "    S.build(arr);",
		  "    ve<int> ans(q);",
		  "    rep(j, 0, q)",
		  "    {",
		  "        int L = B[j][0], R = B[j][1], X = B[j][2], Y = B[j][3];",
		  "        L--, R--;",
		  "        int xcnt = prex[R];",
		  "        ans[j] = preminsum[R];",
		  "        if (L - 1 >= 0)",
		  "        {",
		  "            xcnt -= prex[L - 1];",
		  "            ans[j] -= preminsum[L - 1];",
		  "            ans[j] += rem;",
		  "            ans[j] %= rem;",
		  "        }",
		  "        int ycnt = R - L + 1-xcnt;",
		  "        if (xcnt < X)",
		  "        {",
		  "            ll res = X - xcnt;",
		  "            B[j].pb(res);",
		  "            B[j].pb(0);",
		  "        }",
		  "        else if (ycnt < Y)",
		  "        {",
		  "            ll res = Y - ycnt;",
		  "            B[j].pb(res);",
		  "            B[j].pb(1);",
		  "        }",
		  "        else",
		  "        {",
		  "            B[j].pb(0);",
		  "            B[j].pb(-1);",
		  "        }",
		  "    }",
		  "    rep(j, 0, q)",
		  "    {",
		  "        if (B[j].back() == 1)",
		  "        {",
		  "            B[j].pop_back();",
		  "            int res = B[j].back(), L = B[j][0] - 1, R = B[j][1] - 1;",
		  "            ans[j] += S.query(L, R, res);",
		  "        }",
		  "    }",
		  "    rep(i, 0, n)",
		  "    {",
		  "        if (A[i][0] < A[i][1])",
		  "        {",
		  "            arr[i]=(2e9);",
		  "        }",
		  "        else",
		  "        {",
		  "            arr[i] = (A[i][0] - A[i][1]);",
		  "        }",
		  "    }",
		  "    S.build(arr);",
		  "    rep(j, 0, q)",
		  "    {",
		  "        if (B[j].back() == 0)",
		  "        {",
		  "            B[j].pop_back();",
		  "            int res = B[j].back(), L = B[j][0] - 1, R = B[j][1] - 1;",
		  "            ans[j] += S.query(L, R, res);",
		  "        }",
		  "    }",
		  "    rep (i,0,q)",
		  "    {",
		  "        cout<<ans[i]<<\"\\n\";",
		  "    }",
		  "}",
		  ""
		],
		"description": ""
	  }
}